操作系统：

0、进程和线程的区别？
    （1）进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元
    （2）同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。
    （3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束
    （4）线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的
    （5）线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源
    （6）线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志

1. 一个二进制文件运行出结果，操作系统做了什么（这是一个很全面的题）

2. 死锁的条件及银行家算法、资源分配图之类的
答：死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
死锁条件：
    同时具备下面四个必要条件时，那麽会发生死锁。换句话说，只要下面四个条件有一个不具备，系统就不会出现死锁。
    【1】互斥条件。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。
        必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。
    【2】不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，
        而只能由该资源的占有者进程自行释放。
    【3】占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，
        此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。
    【4】循环等待条件。存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，
        P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。
死锁解决方法：
    一般地，解决死锁的方法分为死锁的预防，避免，检测与恢复三种。
    【1】死锁的预防：打破四个必要条件之一
    【2】

3. 进程间通信方式
    管道
    命名管道
    信号
    信号量
    共享内存
    套接字
    消息队列

4. linux的五种IO方式（阻塞与非阻塞、同步与异步的理解）
    同步模型（synchronous IO）
    阻塞IO（bloking IO）
    非阻塞IO（non-blocking IO）
    多路复用IO（multiplexing IO）
    信号驱动式IO（signal-driven IO）
    异步IO（asynchronous IO）
    
5. linux的select、poll、epoll的区别

6. 进程与线程区别、内核级线程与用户级线程

7. 页面置换算法，尤其是lru

8. 进程调度算法

9. linux中断响应机制

10. 虚拟内存机制

11.hash冲突及其解决方法
    HashMap 采用一种所谓的“Hash 算法”来决定每个元素的存储位置。当程序执行 map.put(String,Obect)方法时，系统将调用
    String的 hashCode() 方法得到其 hashCode 值——每个 Java 对象都有 hashCode() 方法，都可通过该方法获得它的 hashCode 值。
    得到这个对象的 hashCode 值之后，系统会根据该 hashCode 值来决定该元素的存储位置。
    解决方法：
        1.开放定址法
            1.线性探测再散列
            2.二次探测再散列
            3.伪随机探测再散列
                这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，
                如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：
            Hi=（H（key）+di）% m   i=1，2，…，n
            其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：
            线性探测再散列
            dii=1，2，3，…，m-1
            这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。
            二次探测再散列
            di=12，-12，22，-22，…，k2，-k2    ( k<=m/2 )
            这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。
            伪随机探测再散列
            di=伪随机数序列。
            
            具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。
            例如，已知哈希表长度m=11，哈希函数为：H（key）= key  %  11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。
            如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，
            还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。
            如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，
            此时不再冲突，将69填入2号单元。如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，
            仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。
        2.再哈希法
            同时构造多个不同的哈希函数，当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。
            【这种方法不易产生聚集，但增加了计算时间。】
        3.链地址法（拉链法）
            这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。
            【链地址法适用于经常进行插入和删除的情况。】
        4.建立公共溢出区
            将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

12.Windows内存管理方式
    主要分为：页式管理、段式管理和段页式管理。
    页式管理
    原理：是将各进程的虚拟空间划分为若干个长度相等的页。把内存空间按页的大小划分为片或者页面，然后把页式虚拟地址与内存地址建立一一对应的页表，
        并用相应的硬件地址转换机构来解决离散地址变换问题。页式管理采用请求调页和预调页技术来实现内外存存储器的统一管理。
    优点：没有外碎片，每个内碎片不超过页的大小。
    缺点：程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。
    
    段式管理
    原理：是把程序按内容或过程函数关系分成段，每段有自己的名字。一个用户作业或者进程所包含的段对应一个二维线性虚拟空间，也就是一个二维虚拟存储器。
        段式管理程序以段为单位分配内存，然后通过地址映射机构把段式虚拟地址转换为实际内存物理地址。
    优点：可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。
    缺点：会产生碎片。

    段页式管理
    原理：系统必须为每个作业或者进程建立一张段表以管理内存分配与释放、缺段处理等。另外由于一个段又被划分为若干个页，
        每个段必须建立一张页表以把段中的虚页变换为内存中的实际页面。显然与页式管理时相同，页表也要有相应的实现缺页中断处理和页面保护等功能的表项。
    优点：段页式管理是段式管理和页式管理相结合而成，具有两者的优点。
    缺点：由于管理软件的增加，复杂性和开销也增加。另外需要的硬件以及占用的内存也有所增加，使得执行速度下降。